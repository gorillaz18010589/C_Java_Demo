package ob;

public class Ｈ_7_TWID_Matches {

	public static void main(String[] args) {
		//跟格式有關的像帳號有Fuxx,或是抓取格式ip的
		//[] : 判斷指定字元是不是在[]字元集合裡面
		//[A-Z] =>代表Ａ～Ｚ
		//[^xyz]:(反集合)排除這些字元以外的,就是不要x,y,z以外的這些,其他都包含
		//[a-z]:判斷指定字元小寫a-z是不是在[]字元集合裡面,小寫
		//[^a-z]:反集合)排除這些字元小寫a-z以外的,其他都包含
		
		//{n} => 前面的數做幾次
		//{n,} => 前面的數做{n,指定次數}以上
		//{n,m} => 前面的數做{n幾次～m幾次}都可以
		
		//. =>匹配任何字元 
		//() => 刮起來
		// | => 或
		String test ="G123456789";
		
		//第一個字母Ａ是不是在[ABC]字元集合裡面
		if(test.matches("[ABC]123456789")) {  //不是是,因為Ｆ不包含在[ABC]裡
			System.out.println("是"); 
		}else {
			System.out.println("不是");
		}
		
		//判斷第一個字母,是否有Ａ＿Ｚ的範圍,[A-Z] =>代表Ａ～Ｚ
		if(test.matches("[A-Z]123456789")) {  //是,因為Ａ還有含在[A]裡
			System.out.println("是"); 
		}else {
			System.out.println("不是");
		}
		
		//判斷a-z大小寫是否有包含的寫法
		if(test.matches("[a-zA-Z]123456789")) {  //是,因為此招包含a-z的大小寫
			System.out.println("是"); 
		}else {
			System.out.println("不是");
		}
//		======================================
		//[^xyz]:(反集合)排除這些字元以外的,就是不要x,y,z以外的這些,其他都包含
		if(test.matches("[^G]123456789")) {//不是,因為排除Ｇ以外的都有包含,但剛好需要的是Ｇ所以不是
			System.out.println("是"); 
		}else {
			System.out.println("不是");
		}
		
		//直接用正規表示法判斷身分證
		String id = "H123594532";
		//[a-zA-Z][12][0-9]{8} => 
		//[a-zA-Z] => 第一個字母是否包含大小寫a-z
		//[12] => 第二個字母是否包含1或2(因為身分證第二瑪不是1就是2)
		//[0-9]{8} => 第三個數字開始是否包含0~9的數字,{8}代表直接讓前面[0-9]重複8次的意思
		if(id.matches("[a-zA-Z][12][0-9]{8}")) {
			System.out.println("合格的身分證字號格式");  //合格的身分證字號格式
		}else {
			System.out.println("不合格的身分證字號格式");
		}
		
		//*判斷09xx -xxxxxx  前面兩碼開頭固定加-的檢查方式
		String phone = "0912-123456"; 
		if(phone.matches("09[0-9]{2}-[0-9]{6}")) { //前面09固定再來 - 要有不然錯
			System.out.println("合格的電話");  //合格的電話
		}else {
			System.out.println("不合格的電話");
		}
		
		//*判斷IP: 192.168.3.4
		//此招可以從LOG紀錄抓到入侵的IP,可以抓到ip揪出來,只要抓到那個字元的字串,再幫我抓出那個ip
		String ip = "192.168.3.4";
		//n = 0~255
		//192 ip的概念 三位數：不是1就是2 ,二位數是1~9,個位數是0~9的規則
		//1:判斷192的1位數=> [0-9].
		//2.判斷192的92的兩位數 => [1-9][0-9].
		//3.判斷192這三個位數 >
		//3-1: 1:[0-9]{2}.
		//3-2-1:2[0-4][0-9].
		//3-2-2:25[0-5].
		
		//因為是多重組合利用(),｜處理
		//() => 刮起來
		// | => 或
		
		//1.(| | |)
		//2.( [0-9]| |[1-9][0-9] |)
     	//	((([0-9])|([1-9][0-9])||)\.){3} //前面帶點的東西出現三次
	
	}
}


